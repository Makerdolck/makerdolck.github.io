<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Calm Flow">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Calm Flow</title>
<style>
html, body, canvas { margin:0; padding:0; width:100%; height:100%; background:#000; }
  body { overscroll-behavior:none; color-scheme: dark; }
  canvas { touch-action: none; user-select: none; }
  #hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          font-size: 12px; color: rgba(255,255,255,0.6); user-select:none; }
  #pp { position:fixed; right:14px; bottom:14px; z-index:3; width:44px; height:44px;
        border-radius:50%; background:rgba(255,255,255,.08);
        border:1px solid rgba(255,255,255,.12); color:#fff; backdrop-filter:blur(8px);
        cursor:pointer; }
</style>
<link rel="manifest" href="/manifest.webmanifest">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js', { scope:'./' })
      .then(r => console.log('SW registered:', r.scope))
      .catch(e => console.warn('SW registration failed:', e));
  }
</script>
</head>
<body>
<canvas id="c"></canvas>

  
<script>
(function () {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d', { alpha:false, desynchronized:true });

  let w, h, dpr = 1, paused = false, t = 0;
  let cw = 0, ch = 0;                // размеры offscreen
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
   const TAU = Math.PI * 2;

  // ——— Параметры спокойной анимации ———
  const CFG = {
    timeScale: 0.38,     // глобальное замедление времени
    baseScale: 0.38,
    steps: 160,
    morph: 0.30,
    breath: 0.065,
    maskBlur: 28,
    maskContrast: 130,
    trail: 0.052,        // чуть меньший шлейф

    // плавное блуждание центра
    flowK: 1.25,
    flowSpeed: 0.22,
    centerDrift: 55,     // было ~115
    centerFriction: 0.92,

    // форма-«щупальца»
    lobesCount: 7,
    lobeSpinRange: 0.12, // медленнее
    lobeEase: 0.10,      // сглаживание амплитуды

    // мягкие «краски» внутри
    dyes: 36,
    dyeRadius: [0.48, 0.85],
    hueBase: 210, hueSpan: 170,
    hueJitter: 6,        // медленная смена оттенков
    dyeFriction: 0.90,   // инерция
    dyeFlowScale: 60,    // скорость течения пятен
    streaksPerFrame: 0   // без «лучей» для релакса
  };

  // понижение разрешения offscreen ради blur/contrast
  let SCALE = 0.66; // 66% от экрана, можно 0.5 на слабых устройствах
  
  // offscreen
  const mask = document.createElement('canvas'); const mx = mask.getContext('2d');
  const col  = document.createElement('canvas'); const cx2 = col.getContext('2d');

  // фичедетект: поддержка canvas.filter
  const supportsCanvasFilter = (() => {
    const test = document.createElement('canvas').getContext('2d');
    try { test.filter = 'blur(1px) contrast(120%)'; return (''+test.filter).includes('blur'); }
    catch { return false; }
  })();
  
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = c.width  = Math.floor(innerWidth*dpr);
    h = c.height = Math.floor(innerHeight*dpr);
    c.style.width = innerWidth+'px'; c.style.height = innerHeight+'px';
    cw = Math.floor(w * SCALE);
    ch = Math.floor(h * SCALE);
    mask.width = col.width = cw; mask.height = col.height = ch;
    // адаптация blur под DPR/scale
    CFG.maskBlur = Math.round( (28 / dpr) * (SCALE < 1 ? SCALE : 1) );
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // ——— шум/flow ———
  const fract=x=>x-Math.floor(x);
  const hash=(x,y)=>fract(Math.sin(x*127.1+y*311.7)*43758.5453);
  function noise2(x,y){
    const xi=Math.floor(x), yi=Math.floor(y);
    const xf=x-xi, yf=y-yi, u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
    const n00=hash(xi,yi), n10=hash(xi+1,yi), n01=hash(xi,yi+1), n11=hash(xi+1,yi+1);
    return (1-u)*(1-v)*n00 + u*(1-v)*n10 + (1-u)*v*n01 + u*v*n11;
  }
  function fbm(x,y){ let a=0.5,f=1,s=0; for(let i=0;i<4;i++){s+=a*noise2(x*f,y*f); a*=0.5; f*=2.03;} return s; }
  function curl(nx,ny,time){
    const k=CFG.flowK, e=0.004;
    const f=(x,y)=>fbm(k*x + time*CFG.flowSpeed, k*y - time*CFG.flowSpeed*1.17);
    const dx=(f(nx+e,ny)-f(nx-e,ny))/(2*e);
    const dy=(f(nx,ny+e)-f(nx,ny-e))/(2*e);
    return {vx:dy, vy:-dx};
  }

  // ——— состояние: центр с инерцией ———
  let center = { x: w*0.5, y: h*0.5, vx:0, vy:0 };

  // щупальца/впадины
  const lobes = Array.from({length: CFG.lobesCount}, () => ({
    ang: Math.random()*TAU,
    amp: 0.5 + Math.random()*1.2,
    ampSm: 0,                       // сглаженная амплитуда
    width: 0.22 + Math.random()*0.38,
    spin: (Math.random()*2-1)*CFG.lobeSpinRange
  }));

  // «краски» с инерцией
  const dyes = Array.from({length: CFG.dyes}, (_,i)=>({
    x: center.x + (Math.random()*2-1)*Math.min(w,h)*0.12,
    y: center.y + (Math.random()*2-1)*Math.min(w,h)*0.12,
    vx: 0, vy: 0,
    r: CFG.dyeRadius[0] + Math.random()*(CFG.dyeRadius[1]-CFG.dyeRadius[0]),
    hue0: (CFG.hueBase + (i/(CFG.dyes-1)||0)*CFG.hueSpan)%360,
    hueAdd: Math.random()*20-10
  }));

  // форма одной сущности
  function radiusAt(th, R0, time){
    const u = th*2.3 + 0.6*Math.sin(th*3.7 + time*0.5);
    const v = th*4.1 - 0.4*Math.sin(th*2.0 - time*0.4);
    const m = (Math.sin(u + time*0.4) + 0.6*Math.sin(v - time*0.3) + 0.3*Math.sin(th*6.2 + time*0.2))*0.5;
    let spikes = 0;
    for(const l of lobes){
      const d = Math.atan2(Math.sin(th-l.ang), Math.cos(th-l.ang));
      spikes += l.ampSm * Math.exp(-(d*d)/(2*l.width*l.width));
    }
    return R0 * (1 + CFG.morph*m + 0.18*spikes);
  }

  // динамика (замедленная + сглаженная)
  function stepDynamics(dt, time){
    // центр — сила от поля + пружина к середине, с трением
    const f = curl(center.x/w, center.y/h, time);
    center.vx += f.vx * CFG.centerDrift * dt;
    center.vy += f.vy * CFG.centerDrift * dt;
    center.vx += (w*0.5 - center.x) * 0.35 * dt;
    center.vy += (h*0.5 - center.y) * 0.35 * dt;
    center.vx *= CFG.centerFriction;
    center.vy *= CFG.centerFriction;
    center.x  += center.vx * dt;
    center.y  += center.vy * dt;

    // щупальца — медленное плавное вращение и сглаживание амплитуды
    for(const l of lobes){
      l.ang += l.spin * dt;
      const target = l.amp * (0.7 + 0.3*Math.sin(time*0.25 + l.width*5));
      l.ampSm += (target - l.ampSm) * CFG.lobeEase * dt * 12; // easing
    }

    // краски — инерция + слабый поток + пружина к центру
    for(const d of dyes){
      const v = curl(d.x/w, d.y/h, time);
      d.vx += v.vx * CFG.dyeFlowScale * dt;
      d.vy += v.vy * CFG.dyeFlowScale * dt;
      d.vx += (center.x - d.x) * 0.22 * dt;
      d.vy += (center.y - d.y) * 0.22 * dt;
      d.vx *= CFG.dyeFriction; d.vy *= CFG.dyeFriction;
      d.x  += d.vx * dt;       d.y  += d.vy * dt;

      // очень плавная смена оттенка
      d.hueAdd += (Math.random()*2-1) * CFG.hueJitter * dt * 0.25;
    }
  }

  function buildMask(time){
    const sx = cw / w, sy = ch / h;
    const cx = center.x * sx, cy = center.y * sy;
    const R0 = Math.min(cw,ch)*CFG.baseScale * (1 + Math.sin(time*0.8)*CFG.breath*0.5 + Math.sin(time*0.47+1.1)*CFG.breath*0.5);
    mx.globalCompositeOperation = 'source-over';
    mx.clearRect(0,0,cw,ch);
    mx.beginPath();
    for(let i=0;i<=CFG.steps;i++){
      const th=(i/CFG.steps)*TAU;
      const R = radiusAt(th, R0, time);
      const x = cx + Math.cos(th)*R;
      const y = cy + Math.sin(th)*R;
      (i? mx.lineTo(x,y) : mx.moveTo(x,y));
    }
    mx.closePath();
    mx.fillStyle='#fff';
    if (supportsCanvasFilter) {
      mx.filter = `blur(${CFG.maskBlur}px) contrast(${CFG.maskContrast}%)`;
      mx.fill();
      mx.filter='none';
    } else {
      mx.globalAlpha = 0.95; mx.fill(); mx.globalAlpha = 1;
    }
  }

  function paintColors(time){
    const sx = cw / w, sy = ch / h;
    cx2.globalCompositeOperation = 'source-over';
    cx2.clearRect(0,0,cw,ch);
    const Rb = Math.min(cw,ch)*CFG.baseScale;
    for(const d of dyes){
      const x = d.x * sx, y = d.y * sy;
      const rr = Rb * d.r;
      const g = cx2.createRadialGradient(x,y, rr*0.06, x,y, rr);
      const hue = (d.hue0 + d.hueAdd) % 360;
      g.addColorStop(0.0, `hsla(${hue}, 92%, 60%, 0.32)`); // чуть ниже яркость
      g.addColorStop(1.0, `hsla(${(hue+38)%360}, 80%, 40%, 0.02)`);
      cx2.globalCompositeOperation='screen';
      cx2.fillStyle=g;
      cx2.beginPath(); cx2.arc(x,y, rr, 0, TAU); cx2.fill();
    }
  }

  // цикл
  let prev = performance.now();
  function frame(now){
    if(paused) return;
    const rawDt = Math.min(0.033, (now - prev)/1000);
    prev = now;
    const dt = rawDt * CFG.timeScale;
    t += dt;

    // фон/шлейф на основном канвасе
    ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha=1;
    ctx.fillStyle=`rgba(0,0,0,${CFG.trail})`;
    ctx.fillRect(0,0,w,h);

    stepDynamics(dt, t);
    buildMask(t);
    paintColors(t);

    cx2.globalCompositeOperation='destination-in';
    cx2.drawImage(mask,0,0);
    cx2.globalCompositeOperation='screen';
    // апскейл в основной канвас
    ctx.drawImage(col,0,0,w,h);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function toggle(){ paused=!paused; if(!paused){ prev=performance.now(); requestAnimationFrame(frame);} }
  document.getElementById('pp').addEventListener('click', toggle, {passive:true});
  addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.code==='KeyP'){ e.preventDefault(); toggle(); }});
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && !paused) toggle();
    else if (!document.hidden && paused) toggle();
  });
  if (prefersReduced) {
    paused = true;
    // статический кадр
    stepDynamics(0, 0);
    buildMask(0);
    paintColors(0);
    cx2.globalCompositeOperation='destination-in';
    cx2.drawImage(mask,0,0);
    ctx.drawImage(col,0,0,w,h);
  }
})();
</script>





  
</body>
</html>
