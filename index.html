<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Lofi Visual">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Lofi Visual Companion</title>
<meta name="theme-color" content="#000000">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { 
    width: 100%; 
    height: 100%; 
    overflow: hidden;
    background: #000;
    overscroll-behavior: none;
  }
  body { 
    color-scheme: dark;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  canvas { 
    width: 100%;
    height: 100%;
    touch-action: none; 
    user-select: none;
  }
</style>
<link rel="manifest" href="/manifest.webmanifest">
</head>
<body>
<canvas id="c"></canvas>

<script>
(function() {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { 
    alpha: false, 
    desynchronized: true 
  });

  let width, height, dpr = 1;
  const TAU = Math.PI * 2;
  let time = 0;

  // Конфигурация для спокойной lofi-визуализации
  const CONFIG = {
    // Временные параметры
    timeScale: 0.25,          // Медленная анимация для расслабления
    
    // Форма
    baseRadius: 0.35,          // Базовый размер относительно экрана
    breathAmount: 0.08,        // Плавное "дыхание"
    
    // Волны на контуре
    waveCount: 5,              // Количество основных волн
    waveAmplitude: 0.15,       // Амплитуда волн
    waveSpeed: 0.3,            // Скорость изменения волн
    
    // Цвета (пастельная палитра для lofi)
    colorPalette: [
      { h: 280, s: 40, l: 55 }, // Мягкий фиолетовый
      { h: 220, s: 45, l: 60 }, // Спокойный синий
      { h: 180, s: 35, l: 55 }, // Бирюзовый
      { h: 340, s: 40, l: 60 }, // Розовый
      { h: 30,  s: 45, l: 65 }  // Теплый оранжевый
    ],
    colorTransitionSpeed: 0.15,
    
    // Эффекты
    glowIntensity: 0.4,        // Мягкое свечение
    trailOpacity: 0.03,        // След для плавности
    
    // Движение центра
    driftAmount: 0.1,          // Плавающее движение
    driftSpeed: 0.2
  };

  // Состояние
  let center = { x: 0.5, y: 0.5, vx: 0, vy: 0 };
  let currentColorIndex = 0;
  let nextColorIndex = 1;
  let colorTransition = 0;
  
  // Волны формы
  const waves = Array.from({ length: CONFIG.waveCount }, () => ({
    phase: Math.random() * TAU,
    frequency: 1 + Math.random() * 2,
    amplitude: 0.5 + Math.random() * 0.5,
    speed: 0.5 + Math.random() * 0.5
  }));

  // Изменение размера
  function resize() {
    dpr = Math.min(2, window.devicePixelRatio || 1);
    width = canvas.width = Math.floor(window.innerWidth * dpr);
    height = canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }

  // Простой шум для плавного движения
  function noise(x, y, t) {
    return Math.sin(x * 1.2 + t) * Math.cos(y * 1.3 - t * 0.7) * 0.5 + 0.5;
  }

  // Интерполяция цветов
  function interpolateColor(color1, color2, t) {
    return {
      h: color1.h + (color2.h - color1.h) * t,
      s: color1.s + (color2.s - color1.s) * t,
      l: color1.l + (color2.l - color1.l) * t
    };
  }

  // Получение текущего цвета
  function getCurrentColor() {
    const color1 = CONFIG.colorPalette[currentColorIndex];
    const color2 = CONFIG.colorPalette[nextColorIndex];
    return interpolateColor(color1, color2, colorTransition);
  }

  // Обновление состояния
  function update(dt) {
    time += dt * CONFIG.timeScale;
    
    // Плавное движение центра
    const noiseX = noise(time * CONFIG.driftSpeed, 0, time);
    const noiseY = noise(0, time * CONFIG.driftSpeed, time);
    
    center.vx += (noiseX - center.x) * CONFIG.driftAmount * dt;
    center.vy += (noiseY - center.y) * CONFIG.driftAmount * dt;
    center.vx *= 0.95; // Трение
    center.vy *= 0.95;
    
    center.x += center.vx * dt;
    center.y += center.vy * dt;
    
    // Ограничение движения центра
    center.x = Math.max(0.3, Math.min(0.7, center.x));
    center.y = Math.max(0.3, Math.min(0.7, center.y));
    
    // Плавная смена цветов
    colorTransition += CONFIG.colorTransitionSpeed * dt;
    if (colorTransition >= 1) {
      colorTransition = 0;
      currentColorIndex = nextColorIndex;
      nextColorIndex = (nextColorIndex + 1) % CONFIG.colorPalette.length;
    }
    
    // Обновление волн
    waves.forEach(wave => {
      wave.phase += wave.speed * CONFIG.waveSpeed * dt;
    });
  }

  // Рисование формы
  function draw() {
    // Полупрозрачный черный фон для эффекта следа
    ctx.fillStyle = `rgba(0, 0, 0, ${CONFIG.trailOpacity})`;
    ctx.fillRect(0, 0, width, height);
    
    const cx = center.x * width;
    const cy = center.y * height;
    const baseR = Math.min(width, height) * CONFIG.baseRadius;
    
    // Дыхание
    const breathing = 1 + Math.sin(time * 0.5) * CONFIG.breathAmount;
    
    // Получаем текущий цвет
    const color = getCurrentColor();
    
    // Создаем градиент для свечения
    const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseR * breathing * 1.5);
    gradient.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${CONFIG.glowIntensity})`);
    gradient.addColorStop(0.5, `hsla(${color.h}, ${color.s}%, ${color.l * 0.8}%, ${CONFIG.glowIntensity * 0.5})`);
    gradient.addColorStop(1, `hsla(${color.h}, ${color.s}%, ${color.l * 0.6}%, 0)`);
    
    // Рисуем основную форму
    ctx.save();
    ctx.beginPath();
    
    const steps = 100;
    for (let i = 0; i <= steps; i++) {
      const angle = (i / steps) * TAU;
      
      // Вычисляем радиус с учетом волн
      let radius = baseR * breathing;
      waves.forEach(wave => {
        const waveValue = Math.sin(angle * wave.frequency + wave.phase);
        radius += waveValue * wave.amplitude * CONFIG.waveAmplitude * baseR;
      });
      
      // Добавляем мелкую рябь для живости
      radius += Math.sin(angle * 8 + time * 2) * baseR * 0.02;
      
      const x = cx + Math.cos(angle) * radius;
      const y = cy + Math.sin(angle) * radius;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.closePath();
    
    // Применяем градиент и размытие
    ctx.fillStyle = gradient;
    ctx.shadowColor = `hsl(${color.h}, ${color.s}%, ${color.l}%)`;
    ctx.shadowBlur = 30;
    ctx.fill();
    
    // Дополнительное внутреннее свечение
    ctx.globalCompositeOperation = 'screen';
    const innerGradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseR * breathing * 0.7);
    innerGradient.addColorStop(0, `hsla(${color.h}, ${color.s * 1.2}%, ${color.l * 1.2}%, 0.3)`);
    innerGradient.addColorStop(1, `hsla(${color.h}, ${color.s}%, ${color.l}%, 0)`);
    ctx.fillStyle = innerGradient;
    ctx.fill();
    
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  }

  // Анимационный цикл
  let lastTime = performance.now();
  function animate(currentTime) {
    const dt = Math.min((currentTime - lastTime) / 1000, 0.033);
    lastTime = currentTime;
    
    update(dt);
    draw();
    
    requestAnimationFrame(animate);
  }

  // Инициализация
  window.addEventListener('resize', resize, { passive: true });
  resize();
  
  // Запуск анимации
  requestAnimationFrame(animate);

  // Обработка видимости страницы для экономии ресурсов
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      lastTime = performance.now();
    }
  });
})();
</script>

</body>
</html>
