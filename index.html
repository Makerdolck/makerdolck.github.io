<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Calm Flow">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Calm Flow</title>
<style>
  html, body, canvas { margin:0; padding:0; width:100%; height:100%; background:#000; }
  body { overscroll-behavior:none; }
  #hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          font-size: 12px; color: rgba(255,255,255,0.6); user-select:none; }
</style>
<link rel="manifest" href="/manifest.webmanifest">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
</script>
</head>
<body>
<canvas id="c"></canvas>
<!--<div id="hint">Tip: Add to Home Screen for fullscreen · Tap to pause/play</div>-->

  <script>
(function(){
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  let w, h, dpr, paused = false, t = 0;
  const TAU = Math.PI * 2;

  // настройки (можешь играться)
  const CFG = {
    blobsCount: 4,
    baseScale: 0.33,        // базовый размер кляксы относительно min(w,h)
    trailFade: 0.07,        // сила «шлейфа»
    globalAlpha: 0.85,      // общий множитель прозрачности кляксы
    morphAmt: 0.16,         // глубина «рваности» контура
    steps: 90,              // дискретизация контура (чем больше, тем глаже)
  };

  const blobs = Array.from({length: CFG.blobsCount}, (_,i)=> ({
    r: 0.9 + Math.random()*0.3,        // разброс радиуса
    speed: 0.4 + Math.random()*0.5,    // скорость плавания
    phase: Math.random()*TAU,          // фазовый сдвиг для центра
    hue: (i*90 + 200 + Math.random()*40)%360,
    // частоты «гармоник» для кляксы
    k1: 2 + (i%2),
    k2: 3 + ((i+1)%2),
    k3: 5
  }));

  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = c.width  = Math.floor(innerWidth * dpr);
    h = c.height = Math.floor(innerHeight * dpr);
    c.style.width  = innerWidth  + 'px';
    c.style.height = innerHeight + 'px';
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // плавное перемещение «ядер» клякс по эллипсам
  function centerOf(b, t){
    const R = Math.min(w,h) * 0.3;
    const cx = w*0.5 + Math.cos(b.phase + t*b.speed*0.9) * R * 0.35;
    const cy = h*0.5 + Math.sin(b.phase*1.3 + t*b.speed*0.7) * R * 0.28;
    return [cx, cy];
  }

  // радиус как сумма синусоид (даёт бесформенность)
  function radiusAt(theta, base, b, t){
    const m = CFG.morphAmt;
    return base * (
      1
      + m*0.55*Math.sin(theta*b.k1 + t*0.9*b.speed + b.phase*0.7)
      + m*0.30*Math.sin(theta*b.k2 - t*0.6*b.speed)
      + m*0.15*Math.sin(theta*b.k3 + t*0.3)
    );
  }

  function drawBlob(b){
    const [cx, cy] = centerOf(b, t);
    const Rbase = Math.min(w,h) * CFG.baseScale * b.r;

    // мягкий градиент без «пересвета» в центре
    const hue = (b.hue + Math.sin(t*0.5 + b.phase)*18) % 360;
    const grad = ctx.createRadialGradient(cx, cy, Rbase*0.15, cx, cy, Rbase*1.05);
    grad.addColorStop(0.0, `hsla(${hue}, 80%, 60%, 0.35)`);  // меньшая центральная альфа
    grad.addColorStop(1.0, `hsla(${(hue+35)%360}, 80%, 40%, 0.02)`);

    ctx.fillStyle = grad;
    ctx.globalAlpha = CFG.globalAlpha;

    // рисуем замкнутый путь кляксы
    const steps = CFG.steps;
    ctx.beginPath();
    for(let i=0;i<=steps;i++){
      const th = (i/steps)*TAU;
      const r  = radiusAt(th, Rbase, b, t);
      const x  = cx + Math.cos(th)*r;
      const y  = cy + Math.sin(th)*r;
      (i? ctx.lineTo(x,y) : ctx.moveTo(x,y));
    }
    ctx.closePath();
    ctx.fill();
  }

  function frame(){
    if(paused) return;

    t += 0.0035;

    // шлейф
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = `rgba(0,0,0,${CFG.trailFade})`;
    ctx.fillRect(0,0,w,h);

    // мягкое композиционирование без «выбивания в белый»
    ctx.globalCompositeOperation = 'screen';

    for(const b of blobs) drawBlob(b);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);

  function toggle(){
    paused = !paused;
    if(!paused) requestAnimationFrame(frame);
  }
  addEventListener('touchstart', toggle);
  addEventListener('mousedown', toggle);
})();
</script>

  
</body>
</html>
