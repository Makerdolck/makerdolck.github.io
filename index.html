<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Calm Flow">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Calm Flow</title>
<style>
  html, body, canvas { margin:0; padding:0; width:100%; height:100%; background:#000; }
  body { overscroll-behavior:none; }
  #hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          font-size: 12px; color: rgba(255,255,255,0.6); user-select:none; }
</style>
<link rel="manifest" href="/manifest.webmanifest">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
</script>
</head>
<body>
<canvas id="c"></canvas>
<!--<div id="hint">Tip: Add to Home Screen for fullscreen · Tap to pause/play</div>-->


 <script>
(function () {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');

  let w, h, dpr = 1, paused = false, t = 0;
  const TAU = Math.PI * 2;

  // ---------- настройки ----------
  const CFG = {
    // форма + движение
    baseScale: 0.38,        // размер от min(w,h)
    steps: 160,             // детализация контура
    morph: 0.34,            // насколько «рваная» форма (0..0.45)
    breath: 0.10,           // пульс
    maskBlur: 26,           // мягкость края
    maskContrast: 135,
    centerDrift: 115,       // блуждание центра (px/с)
    flowK: 1.6,             // частота поля
    flowSpeed: 0.48,        // скорость поля

    // внутренний цвет (много больших пятен + «струи»)
    dyes: 46,               // сколько цвет-пятен
    dyeRadius: [0.42, 0.82],// мин/макс относительно Rbase
    hueBase: 210, hueSpan: 170,
    hueJitter: 22,          // локальная смена оттенка (°/с)
    streaksPerFrame: 6,     // тонкие «лучи»
    trail: 0.075            // шлейф фона (0..0.12)
  };

  // --- offscreen ---
  const mask = document.createElement('canvas');   const mx  = mask.getContext('2d');
  const col  = document.createElement('canvas');   const cx2 = col.getContext('2d');

  function resize() {
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = c.width  = Math.floor(innerWidth  * dpr);
    h = c.height = Math.floor(innerHeight * dpr);
    c.style.width = innerWidth + 'px';  c.style.height = innerHeight + 'px';
    mask.width = col.width = w; mask.height = col.height = h;
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // ---------- шум / curl-noise ----------
  const fract = x => x - Math.floor(x);
  const hash  = (x,y)=> fract(Math.sin(x*127.1 + y*311.7)*43758.5453);
  function noise2(x,y){
    const xi=Math.floor(x), yi=Math.floor(y);
    const xf=x-xi, yf=y-yi, u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
    const n00=hash(xi,yi), n10=hash(xi+1,yi), n01=hash(xi,yi+1), n11=hash(xi+1,yi+1);
    return (1-u)*(1-v)*n00 + u*(1-v)*n10 + (1-u)*v*n01 + u*v*n11;
  }
  function fbm(x,y){
    let a=0.5,f=1.0,s=0.0; for(let i=0;i<4;i++){ s+=a*noise2(x*f,y*f); a*=0.5; f*=2.03; } return s;
  }
  function curl(nx,ny, time){ // nx,ny ~ 0..1
    const k = CFG.flowK, e = 0.004;
    const f = (x,y)=> fbm(k*x + time*CFG.flowSpeed, k*y - time*CFG.flowSpeed*1.17);
    const dx = (f(nx+e,ny)-f(nx-e,ny))/(2*e);
    const dy = (f(nx,ny+e)-f(nx,ny-e))/(2*e);
    return { vx: dy, vy: -dx };
  }

  // ---------- состояние ----------
  let center = { x: w*0.5, y: h*0.5 };

  // «локальные импульсы» по углу (дают щупальца/провалы)
  const lobes = Array.from({length: 7}, ()=>({
    ang: Math.random()*TAU,
    amp: 0.5 + Math.random()*1.2,
    width: 0.20 + Math.random()*0.45,
    spin: (Math.random()*2-1)*0.5
  }));

  // много мягких цвет-пятен (большие, чтобы не читались как кружки)
  const dyes = Array.from({length: CFG.dyes}, (_,i)=>({
    x: center.x + (Math.random()*2-1)*Math.min(w,h)*0.12,
    y: center.y + (Math.random()*2-1)*Math.min(w,h)*0.12,
    r: CFG.dyeRadius[0] + Math.random()*(CFG.dyeRadius[1]-CFG.dyeRadius[0]),
    hue0: (CFG.hueBase + (i/(CFG.dyes-1)||0)*CFG.hueSpan) % 360,
    dh: 0, // локальная добавка к тону
    drift: Math.random()*TAU
  }));

  // ---------- форма сущности ----------
  function radiusAt(th, R0, time){
    // domain-warped шум по углу → очень неравномерный контур
    const u = th*2.3 + 0.7*Math.sin(th*3.7 + time*0.7);
    const v = th*4.1 - 0.5*Math.sin(th*2.0 - time*0.9);
    const m = (Math.sin(u + time*0.8) + 0.6*Math.sin(v - time*0.6) + 0.3*Math.sin(th*6.2 + time*0.33)) * 0.5;

    // «щупальца» — сумма гауссиан по углу
    let spikes = 0;
    for(const l of lobes){
      const d = Math.atan2(Math.sin(th-l.ang), Math.cos(th-l.ang)); // -pi..pi
      spikes += l.amp * Math.exp(-(d*d)/(2*l.width*l.width));
    }
    return R0 * (1 + CFG.morph*m + 0.18*spikes);
  }

  function buildMask(time){
    // центр живёт
    const flow = curl(center.x/w, center.y/h, time);
    center.x += flow.vx * CFG.centerDrift * dt;
    center.y += flow.vy * CFG.centerDrift * dt;
    center.x += (w*0.5 - center.x) * 0.5 * dt;
    center.y += (h*0.5 - center.y) * 0.5 * dt;
    for(const l of lobes){ l.ang += l.spin*dt; }

    // путь
    const R0 = Math.min(w,h) * CFG.baseScale * (1 + Math.sin(time*0.9)*CFG.breath*0.5 + Math.sin(time*0.57+1.2)*CFG.breath*0.5);
    mx.clearRect(0,0,w,h);
    mx.beginPath();
    for(let i=0;i<=CFG.steps;i++){
      const th=(i/CFG.steps)*TAU;
      const R = radiusAt(th, R0, time);
      const x = center.x + Math.cos(th)*R;
      const y = center.y + Math.sin(th)*R;
      (i? mx.lineTo(x,y) : mx.moveTo(x,y));
    }
    mx.closePath();
    mx.fillStyle = '#fff';
    mx.filter = `blur(${CFG.maskBlur}px) contrast(${CFG.maskContrast}%)`;
    mx.fill();
    mx.filter = 'none';
  }

  // ---------- цвет внутри ----------
  function paintColors(time){
    cx2.clearRect(0,0,w,h);
    const Rb = Math.min(w,h) * CFG.baseScale;

    // крупные пятна
    for(const d of dyes){
      const v = curl(d.x/w, d.y/h, time + Math.sin(d.drift)*0.5);
      d.x += v.vx * 95 * dt; d.y += v.vy * 95 * dt;
      d.x += (center.x - d.x) * 0.85 * dt; // держим внутри
      d.y += (center.y - d.y) * 0.85 * dt;
      d.dh += (Math.random()*2-1) * CFG.hueJitter * dt;

      const rr = Rb * d.r;
      cx2.save();
      // ориентируем пятно по направлению потока → появляется «течение»
      const ang = Math.atan2(v.vy, v.vx);
      cx2.translate(d.x, d.y);
      cx2.rotate(ang);
      cx2.scale(1.6, 0.8); // эллипс
      const g = cx2.createRadialGradient(0,0, rr*0.08, 0,0, rr);
      const hue = (d.hue0 + d.dh) % 360;
      g.addColorStop(0.0, `hsla(${hue}, 92%, 62%, 0.36)`);
      g.addColorStop(1.0, `hsla(${(hue+38)%360}, 80%, 40%, 0.02)`);
      cx2.globalCompositeOperation = 'screen';
      cx2.fillStyle = g;
      cx2.beginPath(); cx2.arc(0,0, rr, 0, TAU); cx2.fill();
      cx2.restore();
    }

    // «лучи»/струи — несколько вытянутых мазков поверх
    for(let i=0;i<CFG.streaksPerFrame;i++){
      const a = Math.random()*TAU;
      const r = Rb*(0.35 + Math.random()*0.7);
      const px = center.x + Math.cos(a)*r*0.6;
      const py = center.y + Math.sin(a)*r*0.6;
      const hue = (CFG.hueBase + Math.random()*CFG.hueSpan) % 360;
      cx2.save();
      cx2.translate(px, py);
      cx2.rotate(a + Math.sin(t*0.7)*0.2);
      cx2.scale(2.2, 0.45);
      const g = cx2.createRadialGradient(0,0, r*0.02, 0,0, r*0.9);
      g.addColorStop(0, `hsla(${hue}, 90%, 60%, 0.12)`);
      g.addColorStop(1, `hsla(${(hue+20)%360}, 80%, 35%, 0.0)`);
      cx2.globalCompositeOperation = 'screen';
      cx2.fillStyle = g;
      cx2.beginPath(); cx2.arc(0,0, r, 0, TAU); cx2.fill();
      cx2.restore();
    }
  }

  // ---------- цикл ----------
  let prev = performance.now(), dt = 0.016;
  function frame(now){
    if (paused) return;
    dt = Math.min(0.033, (now - prev)/1000); prev = now; t += dt;

    // фон/шлейф
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = `rgba(0,0,0,${CFG.trail})`;
    ctx.fillRect(0,0,w,h);

    buildMask(t);
    paintColors(t);

    // обрезаем цвет одной маской → одна сущность
    cx2.globalCompositeOperation = 'destination-in';
    cx2.drawImage(mask, 0, 0);
    cx2.globalCompositeOperation = 'screen';
    ctx.drawImage(col, 0, 0);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function toggle(){ paused = !paused; if(!paused){ prev = performance.now(); requestAnimationFrame(frame);} }
  addEventListener('touchstart', toggle); addEventListener('mousedown', toggle);
})();
</script>




  
</body>
</html>
