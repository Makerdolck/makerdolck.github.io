<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Calm Flow">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Calm Flow</title>
<style>
  html, body, canvas { margin:0; padding:0; width:100%; height:100%; background:#000; }
  body { overscroll-behavior:none; }
  #hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          font-size: 12px; color: rgba(255,255,255,0.6); user-select:none; }
</style>
<link rel="manifest" href="/manifest.webmanifest">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
</script>
</head>
<body>
<canvas id="c"></canvas>
<!--<div id="hint">Tip: Add to Home Screen for fullscreen · Tap to pause/play</div>-->


 <script>
(function () {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');

  let w, h, dpr = 1, paused = false, t = 0;
  const TAU = Math.PI * 2;

  // ------------------- настройки -------------------
  const CFG = {
    // форма и движение сущности
    baseScale: 0.37,      // базовый размер от min(w,h)
    steps: 140,           // детализация контура
    morphA: 0.26,         // «рваность» формы (1D-шума)
    morphB: 0.18,         // вклад «щупалец» (импульсы по углу)
    breath: 0.08,         // дыхание (общий пульс)
    maskBlur: 22,         // мягкость края
    maskContrast: 130,    // контраст маски
    trail: 0.075,         // шлейф фона

    // блуждание центра по curl-noise
    flowK: 1.3,           // частота поля
    flowSpeed: 0.35,      // скорость поля
    centerDrift: 80,      // амплитуда шага центра (px/с)

    // краски внутри
    dyes: 7,
    dyeRadius: 0.66,      // размер цветных пятен (от Rbase)
    hueBase: 210,         // базовый оттенок
    hueSpan: 160,         // размах оттенков
    hueJitter: 18,        // локальная «температура» цвета (°/с)
  };

  // ---------------- offscreen буферы ----------------
  const mask = document.createElement('canvas');
  const mx   = mask.getContext('2d');
  const col  = document.createElement('canvas');
  const cx2  = col.getContext('2d');

  function resize() {
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = c.width  = Math.floor(innerWidth  * dpr);
    h = c.height = Math.floor(innerHeight * dpr);
    c.style.width  = innerWidth  + 'px';
    c.style.height = innerHeight + 'px';
    mask.width = col.width = w;
    mask.height = col.height = h;
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ------------- утилиты шума / curl-noise ----------
  function fract(x){ return x - Math.floor(x); }
  function hash(x,y){ return fract(Math.sin(x*127.1 + y*311.7)*43758.5453); }
  function noise2(x,y){
    const xi=Math.floor(x), yi=Math.floor(y);
    const xf=x-xi, yf=y-yi;
    const u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
    const n00=hash(xi,yi), n10=hash(xi+1,yi), n01=hash(xi,yi+1), n11=hash(xi+1,yi+1);
    return (1-u)*(1-v)*n00 + u*(1-v)*n10 + (1-u)*v*n01 + u*v*n11;
  }
  function fbm(x,y){
    let a=0.5, f=1.0, s=0.0;
    for(let i=0;i<4;i++){ s += a*noise2(x*f, y*f); a*=0.5; f*=2.02; }
    return s;
  }
  function curl(x,y,time){
    // поле от скалярного fbm; curl ~ (df/dy, -df/dx)
    const k = CFG.flowK;
    const e = 0.002;
    const f  = (xx,yy)=>fbm(k*xx + time*CFG.flowSpeed, k*yy - time*CFG.flowSpeed*1.17);
    const dx = (f(x+e,y)-f(x-e,y))/(2*e);
    const dy = (f(x,y+e)-f(x,y-e))/(2*e);
    return { vx: dy, vy: -dx };
  }

  // --------- состояние сущности: центр + «щупальца» ---------
  let center = { x: w*0.5, y: h*0.5 };
  const spikes = Array.from({length: 4}, ()=>({
    ang: Math.random()*TAU,
    w:   0.35 + Math.random()*0.4,   // ширина по углу
    amp: 0.55 + Math.random()*0.9,   // сила вытягивания
    speed: (Math.random()*2-1)*0.35  // скорость вращения
  }));

  // --------- краски (локально меняют оттенок) ---------
  const dyes = Array.from({length: CFG.dyes}, (_,i)=>{
    const a = (i/CFG.dyes)*TAU;
    return {
      x: center.x + Math.cos(a)*Math.min(w,h)*0.12,
      y: center.y + Math.sin(a)*Math.min(w,h)*0.12,
      hue0: (CFG.hueBase + (i/(CFG.dyes-1)||0)*CFG.hueSpan)%360,
      hue: 0,  // динамическая добавка
      drift: Math.random()*TAU
    };
  });

  // --------- форма одной сущности ----------
  function pathShape(g, time){
    const cx = center.x, cy = center.y;
    const R0 = Math.min(w,h) * CFG.baseScale * (1 + Math.sin(time*0.9)*CFG.breath*0.5
                                                  + Math.sin(time*0.53+1.2)*CFG.breath*0.5);
    g.beginPath();
    for (let i=0; i<=CFG.steps; i++){
      const th = (i/CFG.steps)*TAU;

      // 1) «плавная рваность» (дешёвый 1D шум по углу)
      const mA = (Math.sin(th*2.0 + time*0.8) +
                  0.6*Math.sin(th*3.1 - time*0.6) +
                  0.3*Math.sin(th*5.2 + time*0.35)) * 0.5;

      // 2) «щупальца» — сумма движущихся импульсов по углу
      let mB = 0;
      for(const s of spikes){
        const d = Math.atan2(Math.sin(th-s.ang), Math.cos(th-s.ang)); // разность углов (-pi..pi)
        mB += s.amp * Math.exp(-(d*d)/(2*s.w*s.w));
      }
      const R = R0 * (1 + CFG.morphA*mA + CFG.morphB*mB);

      const x = cx + Math.cos(th)*R;
      const y = cy + Math.sin(th)*R;
      (i? g.lineTo(x,y) : g.moveTo(x,y));
    }
    g.closePath();
  }

  // --------- динамика центра/щупалец/красок ----------
  function stepDynamics(dt){
    // центр плывёт по curl-noise
    const v = curl(center.x/w, center.y/h, t);
    center.x += v.vx * CFG.centerDrift * dt;
    center.y += v.vy * CFG.centerDrift * dt;
    // мягко притягиваем к середине, чтобы не уползал за экран
    center.x += (w*0.5 - center.x) * 0.6 * dt;
    center.y += (h*0.5 - center.y) * 0.6 * dt;

    // щупальца медленно вращаются и «дышат»
    for(const s of spikes){
      s.ang += s.speed * dt;
      s.amp += (Math.sin(t*0.7 + s.w*3) * 0.5 - s.amp) * 0.15 * dt; // плавные всплески
    }

    // «краски»: текут по тому же полю + локальная смена оттенка
    const R0 = Math.min(w,h) * CFG.baseScale * CFG.dyeRadius;
    for(const d of dyes){
      const vv = curl(d.x/w, d.y/h, t + Math.sin(d.drift)*0.5);
      d.x += vv.vx * 110 * dt;
      d.y += vv.vy * 110 * dt;
      // подпружинивание к центру, чтобы краска не убегала к краю
      d.x += (center.x - d.x) * 0.9 * dt;
      d.y += (center.y - d.y) * 0.9 * dt;
      // локальная смена цвета: случайный блуждающий тон
      d.hue += (Math.random()*2-1) * CFG.hueJitter * dt;
    }
  }

  // --------- рендер: маска -> цвет -> обрезка ----------
  function buildMask(){
    mx.clearRect(0,0,w,h);
    mx.fillStyle = '#fff';
    pathShape(mx, t);
    mx.filter = `blur(${CFG.maskBlur}px) contrast(${CFG.maskContrast}%)`;
    mx.fill();
    mx.filter = 'none';
  }

  function paintColors(){
    cx2.clearRect(0,0,w,h);
    const R = Math.min(w,h) * CFG.baseScale * CFG.dyeRadius;
    for(const d of dyes){
      const hue = (d.hue0 + d.hue) % 360;
      const g = cx2.createRadialGradient(d.x, d.y, R*0.06, d.x, d.y, R);
      g.addColorStop(0.0, `hsla(${hue}, 92%, 62%, 0.40)`);
      g.addColorStop(1.0, `hsla(${(hue+38)%360}, 80%, 40%, 0.02)`);
      cx2.globalCompositeOperation = 'screen';
      cx2.fillStyle = g;
      cx2.beginPath(); cx2.arc(d.x, d.y, R, 0, TAU); cx2.fill();
    }
  }

  let prev = performance.now();
  function frame(now){
    if (paused) return;
    const dt = Math.min(0.033, (now - prev)/1000); prev = now; t += dt;

    // фон/шлейф
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = `rgba(0,0,0,${CFG.trail})`;
    ctx.fillRect(0,0,w,h);

    stepDynamics(dt);
    buildMask();
    paintColors();

    // обрезаем цвет маской
    cx2.globalCompositeOperation = 'destination-in';
    cx2.drawImage(mask, 0, 0);
    cx2.globalCompositeOperation = 'screen';
    ctx.drawImage(col, 0, 0);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function toggle(){
    paused = !paused;
    if(!paused){ prev = performance.now(); requestAnimationFrame(frame); }
  }
  addEventListener('touchstart', toggle);
  addEventListener('mousedown', toggle);
})();
</script>





  
</body>
</html>
