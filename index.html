<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Calm Flow">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Calm Flow</title>
<style>
  html, body, canvas { margin:0; padding:0; width:100%; height:100%; background:#000; }
  body { overscroll-behavior:none; }
  #hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          font-size: 12px; color: rgba(255,255,255,0.6); user-select:none; }
</style>
<link rel="manifest" href="/manifest.webmanifest">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js');
  }
</script>
</head>
<body>
<canvas id="c"></canvas>
<!--<div id="hint">Tip: Add to Home Screen for fullscreen · Tap to pause/play</div>-->


 <script>
(function () {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');

  let w, h, dpr = 1, paused = false, t = 0;
  const TAU = Math.PI * 2;

  // ---------- настройки ----------
  const CFG = {
    baseScale: 0.36,   // размер сущности относительно min(w,h)
    steps: 140,        // детализация контура
    morph: 0.26,       // «рваность» формы (0..0.4)
    trail: 0.07,       // шлейф фона
    // "краски" внутри
    dyes: 6,
    dyeRadius: 0.55,   // относительный радиус пятен (относительно базового)
    flowK: 1.7,        // частота поля потока
    flowSpeed: 0.42,   // скорость потока
    hueBase: 210,      // базовый оттенок палитры
    hueSpan: 140,      // размах оттенков
  };

  // offscreen для маски и цвета
  const mask = document.createElement('canvas');
  const mx   = mask.getContext('2d');
  const col  = document.createElement('canvas');
  const cx2  = col.getContext('2d');

  function resize() {
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = c.width  = Math.floor(innerWidth  * dpr);
    h = c.height = Math.floor(innerHeight * dpr);
    c.style.width = innerWidth + 'px';
    c.style.height = innerHeight + 'px';
    mask.width = col.width = w;
    mask.height = col.height = h;
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // -------- форма одной сущности --------
  // гладкий псевдо-шум без тяжёлых библиотек
  function n1(x){ return Math.sin(x) * 0.5 + 0.5; }
  function smoothNoise(theta, time, a, b, c) {
    // несколько гармоник -> «органичный» шум
    return (
      0.55 * n1(theta * a + time * 0.8) +
      0.30 * n1(theta * b - time * 0.6) +
      0.15 * n1(theta * c + time * 0.35)
    );
  }
  function pathShape(g) {
    const cx = w * 0.5, cy = h * 0.5;
    const R0 = Math.min(w, h) * CFG.baseScale;
    g.beginPath();
    for (let i = 0; i <= CFG.steps; i++) {
      const th = (i / CFG.steps) * TAU;
      const m = (smoothNoise(th, t, 2.0, 3.0, 5.0) - 0.5) * 2 * CFG.morph;
      const R = R0 * (1 + m);
      const x = cx + Math.cos(th) * R;
      const y = cy + Math.sin(th) * R;
      (i ? g.lineTo(x, y) : g.moveTo(x, y));
    }
    g.closePath();
  }

  // -------- поле потока (вихревое, несжимаемое) --------
  // берём скалярное поле f; скорость = (df/dy, -df/dx)
  function flow(x, y, time) {
    // нормализуем к [-1,1]
    const nx = (x / w) * 2 - 1;
    const ny = (y / h) * 2 - 1;
    const k = CFG.flowK, w1 = CFG.flowSpeed;

    const f  = Math.sin(k*nx + time*w1)
             + Math.sin(k*ny - time*w1*1.2)
             + 0.5*Math.sin(k*(nx+ny) + time*w1*0.7);

    const dfdx = k * ( Math.cos(k*nx + time*w1) + 0.5*Math.cos(k*(nx+ny) + time*w1*0.7) );
    const dfdy = k * ( Math.cos(k*ny - time*w1*1.2) + 0.5*Math.cos(k*(nx+ny) + time*w1*0.7) );

    // curl(f) = (df/dy, -df/dx)
    return { vx: dfdy, vy: -dfdx };
  }

  // «красочки» внутри (они только цвет, форму не задают)
  const dyes = Array.from({length: CFG.dyes}, (_, i) => {
    const a = (i / CFG.dyes) * TAU;
    const R = Math.min(w, h) * CFG.baseScale * 0.35;
    return {
      x: w*0.5 + Math.cos(a)*R,
      y: h*0.5 + Math.sin(a)*R,
      hue: (CFG.hueBase + (i/(CFG.dyes-1)||0)*CFG.hueSpan) % 360,
      phase: Math.random()*TAU
    };
  });

  function updateDyes(dt) {
    for (const d of dyes) {
      const v = flow(d.x, d.y, t + Math.sin(d.phase)*0.5);
      d.x += v.vx * dt * 120;     // масштаб скорости
      d.y += v.vy * dt * 120;

      // мягкое возвращение внутрь, если улетает
      const cx = w*0.5, cy = h*0.5;
      d.x += (cx - d.x) * 0.02 * dt * 60;
      d.y += (cy - d.y) * 0.02 * dt * 60;
    }
  }

  function paintColors() {
    cx2.clearRect(0,0,w,h);
    const R0 = Math.min(w,h) * CFG.baseScale * CFG.dyeRadius;

    // несколько проходов для глубины
    for (const d of dyes) {
      const hue = (d.hue + Math.sin(t*0.6 + d.phase)*18) % 360;
      const g = cx2.createRadialGradient(d.x, d.y, R0*0.1, d.x, d.y, R0);
      g.addColorStop(0.0, `hsla(${hue}, 90%, 62%, 0.42)`);
      g.addColorStop(1.0, `hsla(${(hue+40)%360}, 80%, 40%, 0.02)`);
      cx2.globalCompositeOperation = 'screen';
      cx2.fillStyle = g;
      cx2.beginPath();
      cx2.arc(d.x, d.y, R0, 0, TAU);
      cx2.fill();
    }
  }

  function buildMask() {
    mx.clearRect(0,0,w,h);
    mx.fillStyle = '#fff';
    pathShape(mx);
    mx.filter = 'blur(16px) contrast(130%)'; // мягкий край
    mx.fill();
    mx.filter = 'none';
  }

  let prev = performance.now();
  function frame(now) {
    if (paused) return;
    const dt = Math.min(0.033, (now - prev)/1000); prev = now; t += dt;

    // фон/шлейф
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;
    ctx.fillStyle = `rgba(0,0,0,${CFG.trail})`;
    ctx.fillRect(0,0,w,h);

    // 1) маска одной сущности
    buildMask();

    // 2) цвет внутри (перетекающие краски)
    paintColors();

    // 3) обрезаем цвет маской и рисуем на экран
    cx2.globalCompositeOperation = 'destination-in';
    cx2.drawImage(mask, 0, 0);
    cx2.globalCompositeOperation = 'screen'; // восстановим на следующий кадр
    ctx.drawImage(col, 0, 0);

    updateDyes(dt);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function toggle(){
    paused = !paused;
    if(!paused){ prev = performance.now(); requestAnimationFrame(frame); }
  }
  addEventListener('touchstart', toggle);
  addEventListener('mousedown', toggle);
})();
</script>




  
</body>
</html>
