<!DOCTYPE html>
<html lang="en">
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Calm Flow">
<link rel="apple-touch-icon" href="icon.png">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Calm Flow</title>
<meta name="theme-color" content="#000000">
<style>
html, body, canvas { margin:0; padding:0; width:100%; height:100%; background:#000; }
  body { overscroll-behavior:none; color-scheme: dark; }
  canvas { touch-action: none; user-select: none; }
  #hint { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
          font-size: 12px; color: rgba(255,255,255,0.6); user-select:none; }
  #pp { position:fixed; right:14px; bottom:14px; z-index:3; width:44px; height:44px;
        border-radius:50%; background:rgba(255,255,255,.08);
        border:1px solid rgba(255,255,255,.12); color:#fff; backdrop-filter:blur(8px);
        cursor:pointer; }
</style>
<link rel="manifest" href="/manifest.webmanifest">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js', { scope:'./' })
      .then(r => console.log('SW registered:', r.scope))
      .catch(e => console.warn('SW registration failed:', e));
  }
</script>
</head>
<body>
<canvas id="c"></canvas>
<button id="pp" aria-label="Pause/Play">⏯</button>


  
<script>
(function () {
  const c = document.getElementById('c');
  const ctx = c.getContext('2d', { alpha:false, desynchronized:true });

  let w, h, dpr = 1, paused = false, t = 0;
  let cw = 0, ch = 0;                // размеры offscreen
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
   const TAU = Math.PI * 2;

  // ——— Параметры «кляксы» в духе Я.Музыки ———
  const CFG = {
    timeScale: 0.40,
    steps: 220,              // дискретизация контура
    baseScale: 0.42,         // радиус базовый
    breath: 0.07,            // дыхание
    edgeNoise: 0.06,         // высокочастотная рябь по контуру
    maskBlur: 28,            // мягкий край
    maskContrast: 130,
    trail: 0.055,            // шлейф фона

    // плавный дрейф центра по curl-полю
    flowK: 1.25, flowSpeed: 0.22,
    centerDrift: 60, centerFriction: 0.92,

    // «особенности» контура: выпуклости и вдавлины (метакочки)
    features: 14,                 // сколько «узлов» по кругу
    featSpinRange: 0.18,          // скорость вращения узлов
    featWidth: [0.10, 0.38],      // «ширина» влияния по углу (сигма)
    featAmp:   [0.35, 1.35],      // амплитуда
    dentRatio: 0.45,              // доля вдавлин (negative amplitude)
    featEase:  0.12,              // сглаживание амплитуды

    // мягкие «краски»
    dyes: 40,
    dyeRadius: [0.45, 0.90],
    hueBase: 210, hueSpan: 170, hueJitter: 6,
    dyeFriction: 0.90, dyeFlowScale: 60
  };

  // понижение разрешения offscreen ради blur/contrast
  let SCALE = 0.66; // можно 0.5 на слабых девайсах
  
  // offscreen
  const mask = document.createElement('canvas'); const mx = mask.getContext('2d');
  const col  = document.createElement('canvas'); const cx2 = col.getContext('2d');

  // фичедетект: поддержка canvas.filter
  const supportsCanvasFilter = (() => {
    const test = document.createElement('canvas').getContext('2d');
    try { test.filter = 'blur(1px) contrast(120%)'; return (''+test.filter).includes('blur'); }
    catch { return false; }
  })();
  
  function resize(){
    dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    w = c.width  = Math.floor(innerWidth*dpr);
    h = c.height = Math.floor(innerHeight*dpr);
    c.style.width = innerWidth+'px'; c.style.height = innerHeight+'px';
    cw = Math.floor(w * SCALE);
    ch = Math.floor(h * SCALE);
    mask.width = col.width = cw; mask.height = col.height = ch;
    // адаптация blur под DPR/scale
    CFG.maskBlur = Math.round( (28 / dpr) * (SCALE < 1 ? SCALE : 1) );
  }
  addEventListener('resize', resize, {passive:true}); resize();

  // ——— шум/flow ———
  const fract=x=>x-Math.floor(x);
  const hash=(x,y)=>fract(Math.sin(x*127.1+y*311.7)*43758.5453);
  function noise2(x,y){
    const xi=Math.floor(x), yi=Math.floor(y);
    const xf=x-xi, yf=y-yi, u=xf*xf*(3-2*xf), v=yf*yf*(3-2*yf);
    const n00=hash(xi,yi), n10=hash(xi+1,yi), n01=hash(xi,yi+1), n11=hash(xi+1,yi+1);
    return (1-u)*(1-v)*n00 + u*(1-v)*n10 + (1-u)*v*n01 + u*v*n11;
  }
  function fbm(x,y){ let a=0.5,f=1,s=0; for(let i=0;i<4;i++){s+=a*noise2(x*f,y*f); a*=0.5; f*=2.03;} return s; }
  function curl(nx,ny,time){
    const k=CFG.flowK, e=0.004;
    const f=(x,y)=>fbm(k*x + time*CFG.flowSpeed, k*y - time*CFG.flowSpeed*1.17);
    const dx=(f(nx+e,ny)-f(nx-e,ny))/(2*e);
    const dy=(f(nx,ny+e)-f(nx,ny-e))/(2*e);
    return {vx:dy, vy:-dx};
  }

  // ——— состояние: центр с инерцией ———
  let center = { x: w*0.5, y: h*0.5, vx:0, vy:0 };

  // ——— «особенности» контура: выпуклости (+1) и вдавлины (−1) ———
  const feats = Array.from({length: CFG.features}, (_,i) => {
    const isDent = (i / CFG.features) < CFG.dentRatio;
    const ampMin = CFG.featAmp[0], ampMax = CFG.featAmp[1];
    const width  = CFG.featWidth[0] + Math.random()*(CFG.featWidth[1]-CFG.featWidth[0]);
    return {
      sign: isDent ? -1 : +1,
      ang: Math.random()*TAU,
      amp: ampMin + Math.random()*(ampMax-ampMin),
      ampSm: 0,
      width,
      spin: (Math.random()*2-1)*CFG.featSpinRange
    };
  });

  // «краски» с инерцией
  const dyes = Array.from({length: CFG.dyes}, (_,i)=>({
    x: center.x + (Math.random()*2-1)*Math.min(w,h)*0.12,
    y: center.y + (Math.random()*2-1)*Math.min(w,h)*0.12,
    vx: 0, vy: 0,
    r: CFG.dyeRadius[0] + Math.random()*(CFG.dyeRadius[1]-CFG.dyeRadius[0]),
    hue0: (CFG.hueBase + (i/(CFG.dyes-1)||0)*CFG.hueSpan)%360,
    hueAdd: Math.random()*20-10
  }));

  // профиль радиуса: базовый + сумма выпуклостей и вдавлин + мелкая «рябь»
  function radiusAt(th, R0, time){
    // дыхание
    const breath = 1 + Math.sin(time*0.8)*CFG.breath*0.5 + Math.sin(time*0.47+1.1)*CFG.breath*0.5;
    let delta = 0;
    for(const f of feats){
      const d = Math.atan2(Math.sin(th-f.ang), Math.cos(th-f.ang));        // угол-разность в (−π..π)
      const g = Math.exp(-(d*d)/(2*f.width*f.width));                      // гаусс по углу
      delta += f.sign * f.ampSm * g;
    }
    // мелкая волна для «живости» кромки
    const ripple = CFG.edgeNoise * Math.sin(th*12 + time*0.9) + CFG.edgeNoise*0.6 * Math.sin(th*7.1 - time*0.7);
    return R0 * (breath + 0.18*delta + ripple);
  }

  // динамика (замедленная + сглаженная)
  function stepDynamics(dt, time){
    // центр — сила от поля + пружина к середине, с трением
    const f = curl(center.x/w, center.y/h, time);
    center.vx += f.vx * CFG.centerDrift * dt;
    center.vy += f.vy * CFG.centerDrift * dt;
    center.vx += (w*0.5 - center.x) * 0.35 * dt;
    center.vy += (h*0.5 - center.y) * 0.35 * dt;
    center.vx *= CFG.centerFriction;
    center.vy *= CFG.centerFriction;
    center.x  += center.vx * dt;
    center.y  += center.vy * dt;

    // «особенности» — вращение и плавное перетекание амплитуды
    for(const ftr of feats){
      ftr.ang += ftr.spin * dt;
      const target = ftr.amp * (0.75 + 0.25*Math.sin(time*0.22 + ftr.width*6.0));
      ftr.ampSm += (target - ftr.ampSm) * CFG.featEase * dt * 12;
    }

    // краски — инерция + слабый поток + пружина к центру
    for(const d of dyes){
      const v = curl(d.x/w, d.y/h, time);
      d.vx += v.vx * CFG.dyeFlowScale * dt;
      d.vy += v.vy * CFG.dyeFlowScale * dt;
      d.vx += (center.x - d.x) * 0.22 * dt;
      d.vy += (center.y - d.y) * 0.22 * dt;
      d.vx *= CFG.dyeFriction; d.vy *= CFG.dyeFriction;
      d.x  += d.vx * dt;       d.y  += d.vy * dt;

      // очень плавная смена оттенка
      d.hueAdd += (Math.random()*2-1) * CFG.hueJitter * dt * 0.25;
    }
  }

  function buildMask(time){
    const sx = cw / w, sy = ch / h;
    const cx = center.x * sx, cy = center.y * sy;
    const R0 = Math.min(cw,ch)*CFG.baseScale;
    mx.globalCompositeOperation = 'source-over';
    mx.clearRect(0,0,cw,ch);
    mx.beginPath();
    for(let i=0;i<=CFG.steps;i++){
      const th=(i/CFG.steps)*TAU;
      const R = radiusAt(th, R0, time);
      const x = cx + Math.cos(th)*R;
      const y = cy + Math.sin(th)*R;
      (i? mx.lineTo(x,y) : mx.moveTo(x,y));
    }
    mx.closePath();
    mx.fillStyle='#fff';
    if (supportsCanvasFilter) {
      mx.filter = `blur(${CFG.maskBlur}px) contrast(${CFG.maskContrast}%)`;
      mx.fill();
      mx.filter='none';
    } else {
      mx.globalAlpha = 0.95; mx.fill(); mx.globalAlpha = 1;
    }
  }

  function paintColors(time){
    const sx = cw / w, sy = ch / h;
    cx2.globalCompositeOperation = 'source-over';
    cx2.clearRect(0,0,cw,ch);
    const Rb = Math.min(cw,ch)*CFG.baseScale;
    for(const d of dyes){
      const x = d.x * sx, y = d.y * sy;
      const rr = Rb * d.r;
      const g = cx2.createRadialGradient(x,y, rr*0.06, x,y, rr);
      const hue = (d.hue0 + d.hueAdd) % 360;
      g.addColorStop(0.0, `hsla(${hue}, 92%, 60%, 0.32)`);
      g.addColorStop(1.0, `hsla(${(hue+38)%360}, 80%, 40%, 0.02)`);
      cx2.globalCompositeOperation='screen';
      cx2.fillStyle=g;
      cx2.beginPath(); cx2.arc(x,y, rr, 0, TAU); cx2.fill();
    }
  }

  // цикл
  let prev = performance.now();
  function frame(now){
    if(paused) return;
    const rawDt = Math.min(0.033, (now - prev)/1000);
    prev = now;
    const dt = rawDt * CFG.timeScale;
    t += dt;

    // фон/шлейф на основном канвасе
    ctx.globalCompositeOperation='source-over';
    ctx.globalAlpha=1;
    ctx.fillStyle=`rgba(0,0,0,${CFG.trail})`;
    ctx.fillRect(0,0,w,h);

    stepDynamics(dt, t);
    buildMask(t);
    paintColors(t);

    cx2.globalCompositeOperation='destination-in';
    cx2.drawImage(mask,0,0);
    cx2.globalCompositeOperation='screen';
    // апскейл в основной канвас
    ctx.drawImage(col,0,0,w,h);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function toggle(){ paused=!paused; if(!paused){ prev=performance.now(); requestAnimationFrame(frame);} }
  document.getElementById('pp').addEventListener('click', toggle, {passive:true});
  addEventListener('keydown', (e)=>{ if(e.code==='Space'||e.code==='KeyP'){ e.preventDefault(); toggle(); }});
  document.addEventListener('visibilitychange', () => {
    if (document.hidden && !paused) toggle();
  });
  if (prefersReduced) {
    paused = true;
    // статический кадр
    stepDynamics(0, 0);
    buildMask(0);
    paintColors(0);
    cx2.globalCompositeOperation='destination-in';
    cx2.drawImage(mask,0,0);
    ctx.drawImage(col,0,0,w,h);
  }
})();
</script>





  
</body>
</html>
